"""Real-time telemetry collection and streaming."""

import time
import threading
import numpy as np
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from collections import deque
import json

from ..exceptions import NetworkError
from ..utils.logging import get_logger

logger = get_logger(__name__)


@dataclass
class TelemetryData:
    \"\"\"Telemetry data point.\"\"\"\n    \n    timestamp: float = field(default_factory=time.time)\n    step: int = 0\n    fps: float = 0.0\n    active_agents: int = 0\n    total_agents: int = 0\n    resources_available: int = 0\n    resources_collected: int = 0\n    mean_reward: float = 0.0\n    cpu_usage: float = 0.0\n    memory_usage: float = 0.0\n    custom_metrics: Dict[str, Any] = field(default_factory=dict)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary for serialization.\"\"\"\n        return {\n            \"timestamp\": self.timestamp,\n            \"step\": self.step,\n            \"fps\": self.fps,\n            \"active_agents\": self.active_agents,\n            \"total_agents\": self.total_agents,\n            \"resources_available\": self.resources_available,\n            \"resources_collected\": self.resources_collected,\n            \"mean_reward\": self.mean_reward,\n            \"cpu_usage\": self.cpu_usage,\n            \"memory_usage\": self.memory_usage,\n            \"custom_metrics\": self.custom_metrics\n        }\n    \n    def to_json(self) -> str:\n        \"\"\"Convert to JSON string.\"\"\"\n        return json.dumps(self.to_dict())\n\n\nclass TelemetryCollector:\n    \"\"\"Collects and manages telemetry data from simulations.\"\"\"\n    \n    def __init__(self, \n                 max_history: int = 10000,\n                 collection_interval: float = 0.1,\n                 auto_start: bool = True) -> None:\n        \"\"\"Initialize telemetry collector.\n        \n        Args:\n            max_history: Maximum number of data points to keep\n            collection_interval: Collection interval in seconds\n            auto_start: Whether to start collection automatically\n        \"\"\"\n        self.max_history = max_history\n        self.collection_interval = collection_interval\n        \n        # Data storage\n        self.data_history: deque = deque(maxlen=max_history)\n        self.current_data = TelemetryData()\n        \n        # Collection state\n        self.collecting = False\n        self.collection_thread: Optional[threading.Thread] = None\n        self.lock = threading.RLock()\n        \n        # Callbacks for real-time processing\n        self.callbacks: List[Callable[[TelemetryData], None]] = []\n        \n        # Performance tracking\n        self.last_update_time = time.time()\n        self.update_count = 0\n        \n        if auto_start:\n            self.start_collection()\n        \n        logger.info(f\"Telemetry collector initialized (max_history={max_history})\")\n    \n    def start_collection(self) -> None:\n        \"\"\"Start telemetry collection thread.\"\"\"\n        if self.collecting:\n            logger.warning(\"Telemetry collection already active\")\n            return\n        \n        self.collecting = True\n        self.collection_thread = threading.Thread(\n            target=self._collection_loop,\n            daemon=True\n        )\n        self.collection_thread.start()\n        logger.info(\"Started telemetry collection\")\n    \n    def stop_collection(self) -> None:\n        \"\"\"Stop telemetry collection thread.\"\"\"\n        self.collecting = False\n        if self.collection_thread and self.collection_thread.is_alive():\n            self.collection_thread.join(timeout=2.0)\n        logger.info(\"Stopped telemetry collection\")\n    \n    def update_telemetry(self, **kwargs: Any) -> None:\n        \"\"\"Update current telemetry data.\n        \n        Args:\n            **kwargs: Telemetry fields to update\n        \"\"\"\n        try:\n            with self.lock:\n                # Update timestamp\n                self.current_data.timestamp = time.time()\n                \n                # Update provided fields\n                for key, value in kwargs.items():\n                    if hasattr(self.current_data, key):\n                        setattr(self.current_data, key, value)\n                    else:\n                        # Add to custom metrics\n                        self.current_data.custom_metrics[key] = value\n                \n                self.update_count += 1\n                \n        except Exception as e:\n            logger.error(f\"Failed to update telemetry: {str(e)}\")\n    \n    def record_arena_state(self, arena) -> None:\n        \"\"\"Record telemetry from arena state.\n        \n        Args:\n            arena: Arena instance to collect data from\n        \"\"\"\n        try:\n            # Calculate FPS\n            current_time = time.time()\n            time_delta = current_time - self.last_update_time\n            fps = 1.0 / time_delta if time_delta > 0 else 0.0\n            self.last_update_time = current_time\n            \n            # Agent statistics\n            active_agents = sum(1 for agent in arena.agents.values() if agent.state.alive)\n            total_agents = len(arena.agents)\n            \n            # Environment statistics\n            env_stats = arena.environment.get_stats()\n            resources_available = env_stats.get(\"active_resources\", 0)\n            resources_collected = env_stats.get(\"collected_resources\", 0)\n            \n            # Reward statistics\n            if arena.episode_rewards:\n                recent_rewards = []\n                for agent_rewards in arena.episode_rewards.values():\n                    if agent_rewards:  # If agent has any rewards\n                        recent_rewards.extend(agent_rewards[-10:])  # Last 10 rewards\n                mean_reward = np.mean(recent_rewards) if recent_rewards else 0.0\n            else:\n                mean_reward = 0.0\n            \n            # Update telemetry\n            self.update_telemetry(\n                step=arena.current_step,\n                fps=fps,\n                active_agents=active_agents,\n                total_agents=total_agents,\n                resources_available=resources_available,\n                resources_collected=resources_collected,\n                mean_reward=float(mean_reward)\n            )\n            \n        except Exception as e:\n            logger.error(f\"Failed to record arena state: {str(e)}\")\n    \n    def add_callback(self, callback: Callable[[TelemetryData], None]) -> None:\n        \"\"\"Add callback for real-time telemetry processing.\n        \n        Args:\n            callback: Function to call with each telemetry update\n        \"\"\"\n        self.callbacks.append(callback)\n        logger.debug(f\"Added telemetry callback: {callback.__name__}\")\n    \n    def remove_callback(self, callback: Callable[[TelemetryData], None]) -> None:\n        \"\"\"Remove telemetry callback.\n        \n        Args:\n            callback: Callback function to remove\n        \"\"\"\n        if callback in self.callbacks:\n            self.callbacks.remove(callback)\n            logger.debug(f\"Removed telemetry callback: {callback.__name__}\")\n    \n    def get_latest_data(self) -> TelemetryData:\n        \"\"\"Get latest telemetry data.\n        \n        Returns:\n            Copy of current telemetry data\n        \"\"\"\n        with self.lock:\n            # Create a copy to avoid race conditions\n            data_copy = TelemetryData(\n                timestamp=self.current_data.timestamp,\n                step=self.current_data.step,\n                fps=self.current_data.fps,\n                active_agents=self.current_data.active_agents,\n                total_agents=self.current_data.total_agents,\n                resources_available=self.current_data.resources_available,\n                resources_collected=self.current_data.resources_collected,\n                mean_reward=self.current_data.mean_reward,\n                cpu_usage=self.current_data.cpu_usage,\n                memory_usage=self.current_data.memory_usage,\n                custom_metrics=self.current_data.custom_metrics.copy()\n            )\n            return data_copy\n    \n    def get_history(self, last_n: Optional[int] = None) -> List[TelemetryData]:\n        \"\"\"Get telemetry history.\n        \n        Args:\n            last_n: Number of most recent entries (None for all)\n            \n        Returns:\n            List of telemetry data points\n        \"\"\"\n        with self.lock:\n            history = list(self.data_history)\n            if last_n is not None:\n                history = history[-last_n:]\n            return history\n    \n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get telemetry statistics.\n        \n        Returns:\n            Dictionary of statistics\n        \"\"\"\n        with self.lock:\n            if not self.data_history:\n                return {\"status\": \"no_data\"}\n            \n            # Calculate statistics from history\n            fps_values = [d.fps for d in self.data_history if d.fps > 0]\n            reward_values = [d.mean_reward for d in self.data_history]\n            \n            stats = {\n                \"data_points\": len(self.data_history),\n                \"collection_time\": time.time() - (self.data_history[0].timestamp if self.data_history else time.time()),\n                \"avg_fps\": np.mean(fps_values) if fps_values else 0.0,\n                \"min_fps\": np.min(fps_values) if fps_values else 0.0,\n                \"max_fps\": np.max(fps_values) if fps_values else 0.0,\n                \"avg_reward\": np.mean(reward_values) if reward_values else 0.0,\n                \"update_count\": self.update_count,\n                \"callbacks_count\": len(self.callbacks)\n            }\n            \n            return stats\n    \n    def export_data(self, format: str = \"json\") -> str:\n        \"\"\"Export telemetry data.\n        \n        Args:\n            format: Export format ('json', 'csv')\n            \n        Returns:\n            Exported data as string\n        \"\"\"\n        with self.lock:\n            if format.lower() == \"json\":\n                data_list = [data.to_dict() for data in self.data_history]\n                return json.dumps(data_list, indent=2)\n            \n            elif format.lower() == \"csv\":\n                if not self.data_history:\n                    return \"No data available\"\n                \n                # CSV header\n                first_data = self.data_history[0]\n                headers = list(first_data.to_dict().keys())\n                csv_lines = [','.join(headers)]\n                \n                # CSV data\n                for data in self.data_history:\n                    data_dict = data.to_dict()\n                    row = [str(data_dict.get(header, '')) for header in headers]\n                    csv_lines.append(','.join(row))\n                \n                return '\\n'.join(csv_lines)\n            \n            else:\n                raise ValueError(f\"Unsupported export format: {format}\")\n    \n    def _collection_loop(self) -> None:\n        \"\"\"Background collection loop.\"\"\"\n        logger.debug(\"Telemetry collection loop started\")\n        \n        while self.collecting:\n            try:\n                # Store current data in history\n                with self.lock:\n                    data_copy = self.get_latest_data()\n                    self.data_history.append(data_copy)\n                \n                # Call registered callbacks\n                for callback in self.callbacks:\n                    try:\n                        callback(data_copy)\n                    except Exception as e:\n                        logger.warning(f\"Telemetry callback {callback.__name__} failed: {str(e)}\")\n                \n                time.sleep(self.collection_interval)\n                \n            except Exception as e:\n                logger.error(f\"Telemetry collection loop error: {str(e)}\")\n                time.sleep(self.collection_interval)\n        \n        logger.debug(\"Telemetry collection loop stopped\")\n    \n    def __del__(self) -> None:\n        \"\"\"Cleanup on deletion.\"\"\"\n        try:\n            self.stop_collection()\n        except Exception:\n            pass