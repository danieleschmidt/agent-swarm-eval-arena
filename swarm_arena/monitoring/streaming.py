"""WebSocket streaming server for real-time telemetry."""

import asyncio\nimport websockets\nimport json\nimport threading\nfrom typing import Set, Optional, Dict, Any\nfrom websockets.server import WebSocketServerProtocol\nimport time\n\nfrom .telemetry import TelemetryCollector, TelemetryData\nfrom ..exceptions import NetworkError\nfrom ..utils.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass StreamingServer:\n    \"\"\"WebSocket server for real-time telemetry streaming.\"\"\"\n    \n    def __init__(self, \n                 host: str = \"localhost\",\n                 port: int = 8765,\n                 telemetry_collector: Optional[TelemetryCollector] = None) -> None:\n        \"\"\"Initialize streaming server.\n        \n        Args:\n            host: Server host address\n            port: Server port\n            telemetry_collector: Telemetry collector instance\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.telemetry_collector = telemetry_collector\n        \n        # WebSocket state\n        self.clients: Set[WebSocketServerProtocol] = set()\n        self.server: Optional[websockets.WebSocketServer] = None\n        self.running = False\n        \n        # Streaming state\n        self.streaming_thread: Optional[threading.Thread] = None\n        self.stream_interval = 0.1  # 10 Hz by default\n        \n        # Message statistics\n        self.messages_sent = 0\n        self.clients_connected = 0\n        self.start_time = time.time()\n        \n        logger.info(f\"Streaming server initialized on {host}:{port}\")\n    \n    async def start_server(self) -> None:\n        \"\"\"Start the WebSocket server.\"\"\"\n        try:\n            self.server = await websockets.serve(\n                self.handle_client,\n                self.host,\n                self.port\n            )\n            self.running = True\n            \n            logger.info(f\"Streaming server started on ws://{self.host}:{self.port}\")\n            \n            # Start telemetry streaming\n            if self.telemetry_collector:\n                self.start_streaming()\n            \n        except Exception as e:\n            raise NetworkError(f\"Failed to start streaming server: {str(e)}\")\n    \n    async def stop_server(self) -> None:\n        \"\"\"Stop the WebSocket server.\"\"\"\n        try:\n            self.running = False\n            \n            # Stop streaming\n            self.stop_streaming()\n            \n            # Close all client connections\n            if self.clients:\n                await asyncio.gather(\n                    *[client.close() for client in self.clients],\n                    return_exceptions=True\n                )\n                self.clients.clear()\n            \n            # Close server\n            if self.server:\n                self.server.close()\n                await self.server.wait_closed()\n                self.server = None\n            \n            logger.info(\"Streaming server stopped\")\n            \n        except Exception as e:\n            logger.error(f\"Error stopping streaming server: {str(e)}\")\n    \n    async def handle_client(self, websocket: WebSocketServerProtocol, path: str) -> None:\n        \"\"\"Handle new WebSocket client connection.\n        \n        Args:\n            websocket: WebSocket connection\n            path: Request path\n        \"\"\"\n        client_address = websocket.remote_address\n        logger.info(f\"New client connected from {client_address}\")\n        \n        # Add client to active set\n        self.clients.add(websocket)\n        self.clients_connected += 1\n        \n        try:\n            # Send welcome message\n            welcome_msg = {\n                \"type\": \"welcome\",\n                \"message\": \"Connected to Swarm Arena streaming server\",\n                \"server_info\": {\n                    \"host\": self.host,\n                    \"port\": self.port,\n                    \"stream_interval\": self.stream_interval\n                }\n            }\n            await websocket.send(json.dumps(welcome_msg))\n            \n            # Send current telemetry data if available\n            if self.telemetry_collector:\n                current_data = self.telemetry_collector.get_latest_data()\n                await self.send_telemetry_to_client(websocket, current_data)\n            \n            # Keep connection alive and handle incoming messages\n            async for message in websocket:\n                await self.handle_client_message(websocket, message)\n                \n        except websockets.exceptions.ConnectionClosedError:\n            logger.debug(f\"Client {client_address} disconnected\")\n        except Exception as e:\n            logger.error(f\"Error handling client {client_address}: {str(e)}\")\n        finally:\n            # Remove client from active set\n            self.clients.discard(websocket)\n            logger.debug(f\"Client {client_address} removed from active connections\")\n    \n    async def handle_client_message(self, websocket: WebSocketServerProtocol, message: str) -> None:\n        \"\"\"Handle message from client.\n        \n        Args:\n            websocket: Client WebSocket connection\n            message: JSON message from client\n        \"\"\"\n        try:\n            data = json.loads(message)\n            message_type = data.get(\"type\", \"unknown\")\n            \n            if message_type == \"ping\":\n                # Respond to ping with pong\n                pong_response = {\n                    \"type\": \"pong\",\n                    \"timestamp\": time.time()\n                }\n                await websocket.send(json.dumps(pong_response))\n            \n            elif message_type == \"get_history\":\n                # Send telemetry history\n                if self.telemetry_collector:\n                    last_n = data.get(\"last_n\", 100)\n                    history = self.telemetry_collector.get_history(last_n)\n                    \n                    history_response = {\n                        \"type\": \"history\",\n                        \"data\": [item.to_dict() for item in history]\n                    }\n                    await websocket.send(json.dumps(history_response))\n            \n            elif message_type == \"get_stats\":\n                # Send server statistics\n                stats = self.get_server_stats()\n                stats_response = {\n                    \"type\": \"stats\",\n                    \"data\": stats\n                }\n                await websocket.send(json.dumps(stats_response))\n            \n            elif message_type == \"set_stream_interval\":\n                # Update streaming interval\n                new_interval = data.get(\"interval\", 0.1)\n                if 0.01 <= new_interval <= 10.0:  # Reasonable bounds\n                    self.stream_interval = new_interval\n                    logger.info(f\"Stream interval updated to {new_interval}s\")\n                    \n                    response = {\n                        \"type\": \"stream_interval_updated\",\n                        \"interval\": self.stream_interval\n                    }\n                    await websocket.send(json.dumps(response))\n            \n            else:\n                # Unknown message type\n                error_response = {\n                    \"type\": \"error\",\n                    \"message\": f\"Unknown message type: {message_type}\"\n                }\n                await websocket.send(json.dumps(error_response))\n            \n        except json.JSONDecodeError:\n            error_response = {\n                \"type\": \"error\",\n                \"message\": \"Invalid JSON message\"\n            }\n            await websocket.send(json.dumps(error_response))\n        except Exception as e:\n            logger.error(f\"Error handling client message: {str(e)}\")\n    \n    async def send_telemetry_to_client(self, websocket: WebSocketServerProtocol, data: TelemetryData) -> None:\n        \"\"\"Send telemetry data to specific client.\n        \n        Args:\n            websocket: Client WebSocket connection\n            data: Telemetry data to send\n        \"\"\"\n        try:\n            message = {\n                \"type\": \"telemetry\",\n                \"data\": data.to_dict()\n            }\n            await websocket.send(json.dumps(message))\n            \n        except websockets.exceptions.ConnectionClosedError:\n            # Client disconnected, remove from clients set\n            self.clients.discard(websocket)\n        except Exception as e:\n            logger.warning(f\"Failed to send telemetry to client: {str(e)}\")\n    \n    async def broadcast_telemetry(self, data: TelemetryData) -> None:\n        \"\"\"Broadcast telemetry data to all connected clients.\n        \n        Args:\n            data: Telemetry data to broadcast\n        \"\"\"\n        if not self.clients:\n            return\n        \n        # Create message\n        message = {\n            \"type\": \"telemetry\",\n            \"data\": data.to_dict()\n        }\n        message_json = json.dumps(message)\n        \n        # Send to all clients\n        disconnected_clients = set()\n        \n        for client in self.clients:\n            try:\n                await client.send(message_json)\n                self.messages_sent += 1\n            except websockets.exceptions.ConnectionClosedError:\n                disconnected_clients.add(client)\n            except Exception as e:\n                logger.warning(f\"Failed to send telemetry to client: {str(e)}\")\n                disconnected_clients.add(client)\n        \n        # Remove disconnected clients\n        self.clients -= disconnected_clients\n    \n    def start_streaming(self) -> None:\n        \"\"\"Start background telemetry streaming.\"\"\"\n        if not self.telemetry_collector:\n            logger.warning(\"No telemetry collector available for streaming\")\n            return\n        \n        if self.streaming_thread and self.streaming_thread.is_alive():\n            logger.warning(\"Streaming already active\")\n            return\n        \n        self.streaming_thread = threading.Thread(\n            target=self._streaming_loop,\n            daemon=True\n        )\n        self.streaming_thread.start()\n        logger.info(\"Started telemetry streaming\")\n    \n    def stop_streaming(self) -> None:\n        \"\"\"Stop telemetry streaming.\"\"\"\n        # Note: The streaming loop will stop when self.running becomes False\n        if self.streaming_thread and self.streaming_thread.is_alive():\n            self.streaming_thread.join(timeout=2.0)\n        logger.info(\"Stopped telemetry streaming\")\n    \n    def _streaming_loop(self) -> None:\n        \"\"\"Background streaming loop.\"\"\"\n        logger.debug(\"Telemetry streaming loop started\")\n        \n        while self.running:\n            try:\n                if self.clients and self.telemetry_collector:\n                    # Get latest telemetry data\n                    latest_data = self.telemetry_collector.get_latest_data()\n                    \n                    # Broadcast to all clients (run in event loop)\n                    asyncio.run_coroutine_threadsafe(\n                        self.broadcast_telemetry(latest_data),\n                        asyncio.get_event_loop()\n                    )\n                \n                time.sleep(self.stream_interval)\n                \n            except Exception as e:\n                logger.error(f\"Streaming loop error: {str(e)}\")\n                time.sleep(1.0)  # Wait before retrying\n        \n        logger.debug(\"Telemetry streaming loop stopped\")\n    \n    def get_server_stats(self) -> Dict[str, Any]:\n        \"\"\"Get server statistics.\n        \n        Returns:\n            Dictionary of server statistics\n        \"\"\"\n        uptime = time.time() - self.start_time\n        \n        stats = {\n            \"host\": self.host,\n            \"port\": self.port,\n            \"uptime\": uptime,\n            \"running\": self.running,\n            \"active_clients\": len(self.clients),\n            \"total_clients_connected\": self.clients_connected,\n            \"messages_sent\": self.messages_sent,\n            \"stream_interval\": self.stream_interval,\n            \"messages_per_second\": self.messages_sent / max(1, uptime)\n        }\n        \n        # Add telemetry collector stats if available\n        if self.telemetry_collector:\n            telemetry_stats = self.telemetry_collector.get_statistics()\n            stats[\"telemetry\"] = telemetry_stats\n        \n        return stats\n    \n    def run_forever(self) -> None:\n        \"\"\"Run the server in the current thread (blocking).\"\"\"\n        try:\n            asyncio.run(self._run_server())\n        except KeyboardInterrupt:\n            logger.info(\"Server interrupted by user\")\n        except Exception as e:\n            logger.error(f\"Server error: {str(e)}\")\n    \n    async def _run_server(self) -> None:\n        \"\"\"Internal method to run server.\"\"\"\n        await self.start_server()\n        try:\n            # Keep server running\n            while self.running:\n                await asyncio.sleep(1)\n        finally:\n            await self.stop_server()\n\n\ndef create_streaming_server(arena, host: str = \"localhost\", port: int = 8765) -> StreamingServer:\n    \"\"\"Create a streaming server for an arena.\n    \n    Args:\n        arena: Arena instance to stream from\n        host: Server host\n        port: Server port\n        \n    Returns:\n        Configured streaming server\n    \"\"\"\n    # Create telemetry collector\n    telemetry = TelemetryCollector()\n    \n    # Add callback to collect from arena\n    def collect_arena_telemetry(_: TelemetryData) -> None:\n        telemetry.record_arena_state(arena)\n    \n    telemetry.add_callback(collect_arena_telemetry)\n    \n    # Create streaming server\n    server = StreamingServer(host, port, telemetry)\n    \n    return server