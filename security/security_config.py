"""Security configuration and utilities for Swarm Arena."""\n\nimport os\nimport secrets\nimport hashlib\nimport hmac\nfrom typing import Dict, Any, Optional\nfrom dataclasses import dataclass\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass SecurityConfig:\n    \"\"\"Security configuration for Swarm Arena.\"\"\"\n    \n    # API Security\n    api_key_length: int = 32\n    session_timeout: int = 3600  # 1 hour\n    max_request_rate: int = 100  # requests per minute\n    \n    # Data Security\n    encrypt_telemetry: bool = True\n    hash_agent_ids: bool = False  # For privacy in logs\n    \n    # Network Security\n    allowed_hosts: list = None\n    require_https: bool = True\n    cors_origins: list = None\n    \n    # Logging Security\n    log_sensitive_data: bool = False\n    sanitize_logs: bool = True\n    \n    def __post_init__(self):\n        \"\"\"Initialize security defaults.\"\"\"\n        if self.allowed_hosts is None:\n            self.allowed_hosts = ['localhost', '127.0.0.1']\n        \n        if self.cors_origins is None:\n            self.cors_origins = ['https://localhost', 'https://127.0.0.1']\n\n\nclass SecurityManager:\n    \"\"\"Manages security operations for Swarm Arena.\"\"\"\n    \n    def __init__(self, config: SecurityConfig = None):\n        \"\"\"Initialize security manager.\n        \n        Args:\n            config: Security configuration\n        \"\"\"\n        self.config = config or SecurityConfig()\n        self._api_keys: Dict[str, Dict[str, Any]] = {}\n        self._rate_limits: Dict[str, int] = {}\n    \n    def generate_api_key(self, user_id: str = None) -> str:\n        \"\"\"Generate secure API key.\n        \n        Args:\n            user_id: Optional user identifier\n            \n        Returns:\n            Generated API key\n        \"\"\"\n        api_key = secrets.token_urlsafe(self.config.api_key_length)\n        \n        self._api_keys[api_key] = {\n            'user_id': user_id,\n            'created_at': int(time.time()),\n            'last_used': None,\n            'usage_count': 0\n        }\n        \n        logger.info(f\"Generated API key for user: {user_id or 'anonymous'}\")\n        return api_key\n    \n    def validate_api_key(self, api_key: str) -> bool:\n        \"\"\"Validate API key.\n        \n        Args:\n            api_key: API key to validate\n            \n        Returns:\n            True if valid, False otherwise\n        \"\"\"\n        if api_key not in self._api_keys:\n            logger.warning(f\"Invalid API key attempted: {api_key[:8]}...\")\n            return False\n        \n        key_info = self._api_keys[api_key]\n        key_info['last_used'] = int(time.time())\n        key_info['usage_count'] += 1\n        \n        return True\n    \n    def check_rate_limit(self, client_id: str) -> bool:\n        \"\"\"Check if client is within rate limit.\n        \n        Args:\n            client_id: Client identifier\n            \n        Returns:\n            True if within limit, False otherwise\n        \"\"\"\n        current_time = int(time.time() // 60)  # Per minute\n        key = f\"{client_id}:{current_time}\"\n        \n        current_count = self._rate_limits.get(key, 0)\n        \n        if current_count >= self.config.max_request_rate:\n            logger.warning(f\"Rate limit exceeded for client: {client_id}\")\n            return False\n        \n        self._rate_limits[key] = current_count + 1\n        return True\n    \n    def sanitize_data(self, data: Any) -> Any:\n        \"\"\"Sanitize sensitive data for logging.\n        \n        Args:\n            data: Data to sanitize\n            \n        Returns:\n            Sanitized data\n        \"\"\"\n        if not self.config.sanitize_logs:\n            return data\n        \n        if isinstance(data, dict):\n            sanitized = {}\n            for key, value in data.items():\n                if self._is_sensitive_key(key):\n                    sanitized[key] = \"[SANITIZED]\"\n                else:\n                    sanitized[key] = self.sanitize_data(value)\n            return sanitized\n        \n        elif isinstance(data, list):\n            return [self.sanitize_data(item) for item in data]\n        \n        return data\n    \n    def _is_sensitive_key(self, key: str) -> bool:\n        \"\"\"Check if key contains sensitive information.\"\"\"\n        sensitive_keys = [\n            'password', 'secret', 'key', 'token', 'auth',\n            'credential', 'private', 'sensitive', 'confidential'\n        ]\n        \n        key_lower = key.lower()\n        return any(sensitive in key_lower for sensitive in sensitive_keys)\n    \n    def hash_agent_id(self, agent_id: int, salt: str = None) -> str:\n        \"\"\"Hash agent ID for privacy.\n        \n        Args:\n            agent_id: Agent ID to hash\n            salt: Optional salt for hashing\n            \n        Returns:\n            Hashed agent ID\n        \"\"\"\n        if not self.config.hash_agent_ids:\n            return str(agent_id)\n        \n        if salt is None:\n            salt = os.environ.get('SWARM_ARENA_SALT', 'default_salt')\n        \n        combined = f\"{agent_id}:{salt}\"\n        return hashlib.sha256(combined.encode()).hexdigest()[:16]\n    \n    def create_secure_session(self, user_data: Dict[str, Any]) -> str:\n        \"\"\"Create secure session token.\n        \n        Args:\n            user_data: User session data\n            \n        Returns:\n            Session token\n        \"\"\"\n        session_data = {\n            'user_data': user_data,\n            'created_at': int(time.time()),\n            'expires_at': int(time.time()) + self.config.session_timeout\n        }\n        \n        # In production, store this securely (Redis, database, etc.)\n        session_token = secrets.token_urlsafe(32)\n        \n        logger.info(f\"Created secure session for user: {user_data.get('user_id', 'unknown')}\")\n        return session_token\n    \n    def validate_host(self, host: str) -> bool:\n        \"\"\"Validate if host is allowed.\n        \n        Args:\n            host: Host to validate\n            \n        Returns:\n            True if allowed, False otherwise\n        \"\"\"\n        return host in self.config.allowed_hosts\n    \n    def get_security_headers(self) -> Dict[str, str]:\n        \"\"\"Get security headers for HTTP responses.\n        \n        Returns:\n            Dictionary of security headers\n        \"\"\"\n        headers = {\n            'X-Content-Type-Options': 'nosniff',\n            'X-Frame-Options': 'DENY',\n            'X-XSS-Protection': '1; mode=block',\n            'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',\n            'Content-Security-Policy': \"default-src 'self'; script-src 'self' 'unsafe-inline'\",\n            'Referrer-Policy': 'strict-origin-when-cross-origin',\n            'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'\n        }\n        \n        return headers\n\n\ndef secure_random_position(arena_size: tuple, exclusion_zones: list = None) -> tuple:\n    \"\"\"Generate cryptographically secure random position.\n    \n    Args:\n        arena_size: (width, height) of arena\n        exclusion_zones: List of zones to avoid\n        \n    Returns:\n        (x, y) position\n    \"\"\"\n    max_attempts = 100\n    \n    for _ in range(max_attempts):\n        x = secrets.randbelow(int(arena_size[0]))\n        y = secrets.randbelow(int(arena_size[1]))\n        \n        if exclusion_zones:\n            valid = True\n            for zone in exclusion_zones:\n                if (zone['x_min'] <= x <= zone['x_max'] and \n                    zone['y_min'] <= y <= zone['y_max']):\n                    valid = False\n                    break\n            \n            if valid:\n                return (x, y)\n        else:\n            return (x, y)\n    \n    # Fallback to center if all attempts failed\n    return (arena_size[0] // 2, arena_size[1] // 2)\n\n\ndef verify_signature(data: bytes, signature: str, secret: str) -> bool:\n    \"\"\"Verify HMAC signature.\n    \n    Args:\n        data: Data to verify\n        signature: Signature to check\n        secret: Secret key\n        \n    Returns:\n        True if signature is valid\n    \"\"\"\n    expected = hmac.new(\n        secret.encode(),\n        data,\n        hashlib.sha256\n    ).hexdigest()\n    \n    return hmac.compare_digest(expected, signature)\n\n\ndef create_signature(data: bytes, secret: str) -> str:\n    \"\"\"Create HMAC signature.\n    \n    Args:\n        data: Data to sign\n        secret: Secret key\n        \n    Returns:\n        HMAC signature\n    \"\"\"\n    return hmac.new(\n        secret.encode(),\n        data,\n        hashlib.sha256\n    ).hexdigest()\n\n\n# Security audit utilities\ndef audit_log(event: str, details: Dict[str, Any], severity: str = \"INFO\") -> None:\n    \"\"\"Log security events for auditing.\n    \n    Args:\n        event: Event type\n        details: Event details\n        severity: Log severity\n    \"\"\"\n    audit_logger = logging.getLogger('security_audit')\n    \n    audit_entry = {\n        'timestamp': int(time.time()),\n        'event': event,\n        'severity': severity,\n        'details': details\n    }\n    \n    if severity == \"CRITICAL\":\n        audit_logger.critical(f\"SECURITY: {event} - {details}\")\n    elif severity == \"WARNING\":\n        audit_logger.warning(f\"SECURITY: {event} - {details}\")\n    else:\n        audit_logger.info(f\"SECURITY: {event} - {details}\")\n\n\n# Import time for timestamp functions\nimport time"